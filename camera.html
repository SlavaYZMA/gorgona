<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eye Recording</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            position: relative;
        }

        .back-arrow {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #888;
            text-decoration: none;
            font-size: 24px;
            cursor: pointer;
            transition: color 0.2s;
            z-index: 100;
        }

        .back-arrow:hover {
            color: #fff;
        }

        .instruction {
            color: #fff;
            font-size: 32px;
            text-align: center;
            margin-top: 60px;
            margin-bottom: 40px;
            padding: 0 20px;
        }

        .frame-container {
            position: relative;
            width: 512px;
            height: 128px;
            border: 2px solid #fff;
            border-radius: 12px;
            overflow: hidden;
            background: #000;
        }

        #videoElement {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            min-width: 100%;
            min-height: 100%;
            object-fit: cover;
        }

        #previewVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: none;
        }

        .timer {
            color: #fff;
            font-size: 120px;
            font-weight: 300;
            margin-top: 40px;
            font-variant-numeric: tabular-nums;
            letter-spacing: -5px;
        }

        .status-text {
            color: #888;
            font-size: 16px;
            margin-top: 20px;
            text-align: center;
        }

        .buttons-container {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: 40px;
        }

        .btn {
            background: transparent;
            color: #fff;
            border: 2px solid #fff;
            padding: 15px 40px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s;
            min-width: 280px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn:hover {
            background: #fff;
            color: #000;
        }

        .btn-primary {
            background: #fff;
            color: #000;
        }

        .btn-primary:hover {
            background: #ddd;
            border-color: #ddd;
        }

        .hidden {
            display: none !important;
        }

        #hiddenCanvas {
            display: none;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js" crossorigin="anonymous"></script>
</head>
<body>
    <a href="index.html" class="back-arrow">←</a>
    
    <h1 class="instruction" id="instruction">Поднеси глаза к рамке и держи взгляд</h1>
    
    <div class="frame-container" id="frameContainer">
        <video id="videoElement" autoplay playsinline muted></video>
        <video id="previewVideo" playsinline loop muted></video>
    </div>
    
    <div class="timer" id="timer">7</div>
    
    <div class="status-text" id="statusText">Ожидание обнаружения глаз...</div>
    
    <div class="buttons-container" id="buttonsContainer">
        <button class="btn" id="retryBtn">ЗАПИСАТЬ ЗАНОВО</button>
        <button class="btn btn-primary" id="saveBtn">ОСТАВИТЬ НАВСЕГДА</button>
        <button class="btn" id="downloadBtn">СКАЧАТЬ НА КОМПЬЮТЕР</button>
    </div>

    <canvas id="hiddenCanvas"></canvas>

    <script>
        (function() {
            // DOM Elements
            const videoElement = document.getElementById('videoElement');
            const previewVideo = document.getElementById('previewVideo');
            const frameContainer = document.getElementById('frameContainer');
            const timerDisplay = document.getElementById('timer');
            const statusText = document.getElementById('statusText');
            const buttonsContainer = document.getElementById('buttonsContainer');
            const instruction = document.getElementById('instruction');
            const retryBtn = document.getElementById('retryBtn');
            const saveBtn = document.getElementById('saveBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            const hiddenCanvas = document.getElementById('hiddenCanvas');

            // State
            let mediaStream = null;
            let mediaRecorder = null;
            let recordedChunks = [];
            let recordedBlob = null;
            let faceMesh = null;
            let camera = null;

            let isRecording = false;
            let recordingStartTime = 0;
            let timerValue = 7;
            let timerInterval = null;

            let eyesInFrame = false;
            let eyesStableStartTime = 0;
            let eyesClosedStartTime = 0;
            let lastHeadPosition = null;
            let headJerkThreshold = 50;
            let eyeClosedThreshold = 0.02;
            let requiredStableTime = 500;

            let blinkStartTime = 0;
            let isBlinking = false;
            let blinkDurationThreshold = 300;

            // Frame dimensions
            const FRAME_WIDTH = 512;
            const FRAME_HEIGHT = 128;

            // Initialize
            async function init() {
                try {
                    await setupCamera();
                    await setupFaceMesh();
                    statusText.textContent = 'Камера готова. Поместите глаза в рамку.';
                } catch (error) {
                    console.error('Initialization error:', error);
                    statusText.textContent = 'Ошибка: ' + error.message;
                    // Try fallback
                    tryFallbackDetection();
                }
            }

            async function setupCamera() {
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: 'user',
                        frameRate: { ideal: 20, max: 30 }
                    },
                    audio: false
                });

                videoElement.srcObject = mediaStream;
                await new Promise(resolve => {
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        resolve();
                    };
                });
            }

            async function setupFaceMesh() {
                return new Promise((resolve, reject) => {
                    try {
                        faceMesh = new FaceMesh({
                            locateFile: (file) => {
                                return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/${file}`;
                            }
                        });

                        faceMesh.setOptions({
                            maxNumFaces: 1,
                            refineLandmarks: true,
                            minDetectionConfidence: 0.5,
                            minTrackingConfidence: 0.5
                        });

                        faceMesh.onResults(onFaceMeshResults);

                        camera = new Camera(videoElement, {
                            onFrame: async () => {
                                if (faceMesh && !isRecording) {
                                    await faceMesh.send({ image: videoElement });
                                }
                            },
                            width: 1280,
                            height: 720
                        });

                        camera.start().then(resolve).catch(reject);
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            function tryFallbackDetection() {
                statusText.textContent = 'Используется упрощённое определение...';
                
                // Fallback: simple motion-based detection
                let previousFrame = null;
                const detectionCanvas = document.createElement('canvas');
                detectionCanvas.width = 160;
                detectionCanvas.height = 120;
                const detectionCtx = detectionCanvas.getContext('2d');

                let stableFrameCount = 0;
                const requiredStableFrames = 30;

                function detectMotion() {
                    if (isRecording || !videoElement.videoWidth) {
                        requestAnimationFrame(detectMotion);
                        return;
                    }

                    detectionCtx.drawImage(videoElement, 0, 0, 160, 120);
                    const currentFrame = detectionCtx.getImageData(0, 0, 160, 120);

                    if (previousFrame) {
                        let diff = 0;
                        for (let i = 0; i < currentFrame.data.length; i += 4) {
                            diff += Math.abs(currentFrame.data[i] - previousFrame.data[i]);
                        }
                        diff /= (currentFrame.data.length / 4);

                        if (diff < 10) {
                            stableFrameCount++;
                            if (stableFrameCount >= requiredStableFrames && !eyesInFrame) {
                                eyesInFrame = true;
                                eyesStableStartTime = Date.now();
                                statusText.textContent = 'Обнаружено стабильное положение';
                                startTimerCountdown();
                            }
                        } else {
                            if (diff > 30 && eyesInFrame) {
                                // Head jerk detected
                                resetTimer('Обнаружено резкое движение');
                            }
                            stableFrameCount = 0;
                        }
                    }

                    previousFrame = currentFrame;
                    requestAnimationFrame(detectMotion);
                }

                detectMotion();
            }

            function onFaceMeshResults(results) {
                if (isRecording) return;

                if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
                    if (eyesInFrame) {
                        resetTimer('Глаза не обнаружены');
                    }
                    eyesInFrame = false;
                    return;
                }

                const landmarks = results.multiFaceLandmarks[0];

                // Eye landmarks indices for iris
                const leftEyeIndices = [33, 160, 158, 133, 153, 144];
                const rightEyeIndices = [362, 385, 387, 263, 373, 380];
                const leftIrisIndices = [468, 469, 470, 471, 472];
                const rightIrisIndices = [473, 474, 475, 476, 477];

                // Calculate eye center positions
                const leftEyeCenter = getCenter(landmarks, leftEyeIndices);
                const rightEyeCenter = getCenter(landmarks, rightEyeIndices);
                const eyesCenterY = (leftEyeCenter.y + rightEyeCenter.y) / 2;
                const eyesCenterX = (leftEyeCenter.x + rightEyeCenter.x) / 2;

                // Check if eyes are in the frame area (middle third vertically, middle horizontally)
                const inFrameY = eyesCenterY > 0.35 && eyesCenterY < 0.65;
                const inFrameX = eyesCenterX > 0.25 && eyesCenterX < 0.75;

                // Check for eye closure using Eye Aspect Ratio
                const leftEAR = calculateEAR(landmarks, [33, 160, 158, 133, 153, 144]);
                const rightEAR = calculateEAR(landmarks, [362, 385, 387, 263, 373, 380]);
                const avgEAR = (leftEAR + rightEAR) / 2;

                const eyesClosed = avgEAR < eyeClosedThreshold;

                // Handle blinking vs prolonged closure
                if (eyesClosed) {
                    if (!isBlinking && blinkStartTime === 0) {
                        blinkStartTime = Date.now();
                        isBlinking = true;
                    } else if (Date.now() - blinkStartTime > 1500) {
                        // Eyes closed for more than 1.5 seconds
                        if (eyesInFrame) {
                            resetTimer('Глаза закрыты слишком долго');
                        }
                        return;
                    }
                } else {
                    if (isBlinking && Date.now() - blinkStartTime < blinkDurationThreshold) {
                        // This was just a blink, ignore
                    }
                    blinkStartTime = 0;
                    isBlinking = false;
                }

                // Check for head jerk
                const currentHeadPos = {
                    x: landmarks[1].x,
                    y: landmarks[1].y,
                    z: landmarks[1].z
                };

                if (lastHeadPosition) {
                    const movement = Math.sqrt(
                        Math.pow((currentHeadPos.x - lastHeadPosition.x) * 1000, 2) +
                        Math.pow((currentHeadPos.y - lastHeadPosition.y) * 1000, 2)
                    );

                    if (movement > headJerkThreshold) {
                        if (eyesInFrame) {
                            resetTimer('Обнаружен резкий рывок головы');
                        }
                        lastHeadPosition = currentHeadPos;
                        return;
                    }
                }
                lastHeadPosition = currentHeadPos;

                // Update state
                if (inFrameY && inFrameX && !eyesClosed) {
                    if (!eyesInFrame) {
                        eyesInFrame = true;
                        eyesStableStartTime = Date.now();
                        statusText.textContent = 'Глаза обнаружены. Держите взгляд...';
                    }

                    // Check if stable enough to start countdown
                    if (Date.now() - eyesStableStartTime > requiredStableTime && !timerInterval) {
                        startTimerCountdown();
                    }
                } else {
                    if (eyesInFrame && !isBlinking) {
                        resetTimer('Глаза вышли из рамки');
                    }
                    eyesInFrame = false;
                }
            }

            function getCenter(landmarks, indices) {
                let sumX = 0, sumY = 0;
                for (const idx of indices) {
                    sumX += landmarks[idx].x;
                    sumY += landmarks[idx].y;
                }
                return {
                    x: sumX / indices.length,
                    y: sumY / indices.length
                };
            }

            function calculateEAR(landmarks, indices) {
                // Eye Aspect Ratio calculation
                const p1 = landmarks[indices[0]];
                const p2 = landmarks[indices[1]];
                const p3 = landmarks[indices[2]];
                const p4 = landmarks[indices[3]];
                const p5 = landmarks[indices[4]];
                const p6 = landmarks[indices[5]];

                const vertical1 = Math.sqrt(Math.pow(p2.x - p6.x, 2) + Math.pow(p2.y - p6.y, 2));
                const vertical2 = Math.sqrt(Math.pow(p3.x - p5.x, 2) + Math.pow(p3.y - p5.y, 2));
                const horizontal = Math.sqrt(Math.pow(p1.x - p4.x, 2) + Math.pow(p1.y - p4.y, 2));

                return (vertical1 + vertical2) / (2.0 * horizontal);
            }

            function startTimerCountdown() {
                if (timerInterval) return;

                statusText.textContent = 'Запись начнётся через...';
                timerValue = 7;
                timerDisplay.textContent = timerValue;

                timerInterval = setInterval(() => {
                    timerValue--;
                    timerDisplay.textContent = timerValue;

                    if (timerValue <= 0) {
                        clearInterval(timerInterval);
                        timerInterval = null;
                        startRecording();
                    }
                }, 1000);
            }

            function resetTimer(reason) {
                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
                timerValue = 7;
                timerDisplay.textContent = timerValue;
                eyesInFrame = false;
                eyesStableStartTime = 0;
                statusText.textContent = reason || 'Таймер сброшен';
            }

            function startRecording() {
                isRecording = true;
                recordedChunks = [];
                statusText.textContent = 'Идёт запись...';
                instruction.textContent = 'Запись...';

                // Setup canvas for recording at correct resolution
                hiddenCanvas.width = FRAME_WIDTH;
                hiddenCanvas.height = FRAME_HEIGHT;
                const ctx = hiddenCanvas.getContext('2d');

                // Create canvas stream
                const canvasStream = hiddenCanvas.captureStream(20);

                // Draw video to canvas with correct cropping
                function drawFrame() {
                    if (!isRecording) return;

                    const videoWidth = videoElement.videoWidth;
                    const videoHeight = videoElement.videoHeight;

                    // Calculate crop area to get eyes region
                    const aspectRatio = FRAME_WIDTH / FRAME_HEIGHT;
                    let sourceWidth = videoWidth;
                    let sourceHeight = videoWidth / aspectRatio;

                    if (sourceHeight > videoHeight) {
                        sourceHeight = videoHeight;
                        sourceWidth = videoHeight * aspectRatio;
                    }

                    const sourceX = (videoWidth - sourceWidth) / 2;
                    const sourceY = (videoHeight - sourceHeight) / 2;

                    ctx.drawImage(
                        videoElement,
                        sourceX, sourceY, sourceWidth, sourceHeight,
                        0, 0, FRAME_WIDTH, FRAME_HEIGHT
                    );

                    requestAnimationFrame(drawFrame);
                }
                drawFrame();

                // Setup MediaRecorder
                const mimeType = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') 
                    ? 'video/webm;codecs=vp9' 
                    : MediaRecorder.isTypeSupported('video/webm;codecs=vp8')
                        ? 'video/webm;codecs=vp8'
                        : 'video/webm';

                mediaRecorder = new MediaRecorder(canvasStream, {
                    mimeType: mimeType,
                    videoBitsPerSecond: 1000000
                });

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data && event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    recordedBlob = new Blob(recordedChunks, { type: mimeType });
                    showPreview();
                };

                mediaRecorder.start(100);
                recordingStartTime = Date.now();

                // Stop recording after 7 seconds
                setTimeout(() => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                        isRecording = false;
                    }
                }, 7000);

                // Update timer during recording
                let recordTimer = 7;
                const recordInterval = setInterval(() => {
                    recordTimer--;
                    timerDisplay.textContent = recordTimer;
                    if (recordTimer <= 0) {
                        clearInterval(recordInterval);
                    }
                }, 1000);
            }

            function showPreview() {
                videoElement.style.display = 'none';
                previewVideo.style.display = 'block';
                previewVideo.src = URL.createObjectURL(recordedBlob);
                previewVideo.play();

                timerDisplay.style.display = 'none';
                statusText.style.display = 'none';
                buttonsContainer.style.display = 'flex';
                instruction.textContent = 'Запись завершена';
            }

            function resetToRecording() {
                videoElement.style.display = 'block';
                previewVideo.style.display = 'none';
                previewVideo.src = '';

                timerDisplay.style.display = 'block';
                timerDisplay.textContent = '7';
                statusText.style.display = 'block';
                statusText.textContent = 'Ожидание обнаружения глаз...';
                buttonsContainer.style.display = 'none';
                instruction.textContent = 'Поднеси глаза к рамке и держи взгляд';

                recordedChunks = [];
                recordedBlob = null;
                isRecording = false;
                eyesInFrame = false;
                eyesStableStartTime = 0;
                lastHeadPosition = null;
            }

            async function saveForever() {
                if (!recordedBlob) {
                    console.error('No recorded video to save');
                    return;
                }

                statusText.style.display = 'block';
                statusText.textContent = 'Сохранение...';

                try {
                    const formData = new FormData();
                    formData.append('video', recordedBlob, 'eye-recording.webm');

                    // Netlify Function endpoint (placeholder)
                    const response = await fetch('/.netlify/functions/save-video', {
                        method: 'POST',
                        body: formData
                    });

                    if (response.ok) {
                        console.log('Video saved successfully');
                        statusText.textContent = 'Сохранено!';
                    } else {
                        console.log('Server response:', response.status);
                        statusText.textContent = 'Запрос отправлен (тестовый режим)';
                    }
                } catch (error) {
                    console.log('Save request attempted:', error.message);
                    statusText.textContent = 'Запрос отправлен (тестовый режим)';
                }
            }

            function downloadVideo() {
                if (!recordedBlob) {
                    console.error('No recorded video to download');
                    return;
                }

                const url = URL.createObjectURL(recordedBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'eye-recording-' + Date.now() + '.webm';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // Event listeners
            retryBtn.addEventListener('click', resetToRecording);
            saveBtn.addEventListener('click', saveForever);
            downloadBtn.addEventListener('click', downloadVideo);

            // Initialize on load
            init();
        })();
    </script>
</body>
</html>
